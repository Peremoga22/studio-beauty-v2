/*!
Waypoints - 4.0.1 (переписаний)
Автор: Caleb Troughton
Ліцензія: MIT
*/

(function () {
    "use strict";

    // Змінні
    let waypointCounter = 0;
    const allWaypoints = {};

    function Waypoint(options) {
        if (!options) throw new Error("Не передано опцій для конструктора Waypoint.");
        if (!options.element) throw new Error("Не вказано елемент у параметрах Waypoint.");
        if (!options.handler) throw new Error("Не вказано обробник (handler) у параметрах Waypoint.");

        // Унікальний ключ
        this.key = "waypoint-" + waypointCounter;

        // Об'єднання параметрів користувача з дефолтними
        this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options);

        // Зберігаємо DOM-елемент
        this.element = this.options.element;

        // Адаптер (jQuery або інший)
        this.adapter = new Waypoint.Adapter(this.element);

        // Колбек, який викликається при спрацьовуванні
        this.callback = options.handler;

        // Вісь: вертикальна чи горизонтальна
        this.axis = this.options.horizontal ? "horizontal" : "vertical";

        // Чи активний
        this.enabled = this.options.enabled;

        // Коли спрацює
        this.triggerPoint = null;

        // Група та контекст
        this.group = Waypoint.Group.findOrCreate({
            name: this.options.group,
            axis: this.axis
        });

        this.context = Waypoint.Context.findOrCreateByElement(this.options.context);

        // Обробка псевдонімів offset
        if (Waypoint.offsetAliases[this.options.offset]) {
            this.options.offset = Waypoint.offsetAliases[this.options.offset];
        }

        // Реєстрація
        this.group.add(this);
        this.context.add(this);
        allWaypoints[this.key] = this;

        // Лічильник
        waypointCounter += 1;
    }

    // Методи Waypoint
    Waypoint.prototype.queueTrigger = function (direction) {
        this.group.queueTrigger(this, direction);
    };

    Waypoint.prototype.trigger = function (args) {
        if (this.enabled && this.callback) {
            this.callback.apply(this, args);
        }
    };

    Waypoint.prototype.destroy = function () {
        this.context.remove(this);
        this.group.remove(this);
        delete allWaypoints[this.key];
    };

    Waypoint.prototype.disable = function () {
        this.enabled = false;
        return this;
    };

    Waypoint.prototype.enable = function () {
        this.context.refresh();
        this.enabled = true;
        return this;
    };

    Waypoint.prototype.next = function () {
        return this.group.next(this);
    };

    Waypoint.prototype.previous = function () {
        return this.group.previous(this);
    };

    // Статичні методи
    Waypoint.invokeAll = function (methodName) {
        const waypointsArray = Object.values(allWaypoints);
        for (const wp of waypointsArray) {
            wp[methodName]();
        }
    };

    Waypoint.destroyAll = function () {
        Waypoint.invokeAll("destroy");
    };

    Waypoint.disableAll = function () {
        Waypoint.invokeAll("disable");
    };

    Waypoint.enableAll = function () {
        Waypoint.Context.refreshAll();
        for (const key in allWaypoints) {
            allWaypoints[key].enabled = true;
        }
        return this;
    };

    Waypoint.refreshAll = function () {
        Waypoint.Context.refreshAll();
    };

    Waypoint.viewportHeight = function () {
        return window.innerHeight || document.documentElement.clientHeight;
    };

    Waypoint.viewportWidth = function () {
        return document.documentElement.clientWidth;
    };

    // Статичні поля
    Waypoint.adapters = [];
    Waypoint.defaults = {
        context: window,
        continuous: true,
        enabled: true,
        group: "default",
        horizontal: false,
        offset: 0
    };

    Waypoint.offsetAliases = {
        "bottom-in-view": function () {
            return this.context.innerHeight() - this.adapter.outerHeight();
        },
        "right-in-view": function () {
            return this.context.innerWidth() - this.adapter.outerWidth();
        }
    };

    // Додаємо глобально
    window.Waypoint = Waypoint;
})();
